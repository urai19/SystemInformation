import { __assign, __awaiter, __generator } from "tslib";
import { Status } from '@amplitude/types';
import { AsyncQueue, mapJSONToResponse, mapHttpMessageToResponse } from '@amplitude/utils';
import * as http from 'http';
import * as https from 'https';
import { REQUEST_TIMEOUT_MILLIS_DEFAULT } from '../constants';
/** Base Transport class implementation */
var HTTPTransport = /** @class */ (function () {
    /** Create instance and set this.dsn */
    function HTTPTransport(options) {
        this.options = options;
        this._uploadInProgress = false;
        this._requestQueue = new AsyncQueue();
        this.options = options;
        if (options.serverUrl.startsWith('http://')) {
            this.module = http;
        }
        else if (options.serverUrl.startsWith('https://')) {
            this.module = https;
        }
        else {
            throw new Error('Invalid server url');
        }
    }
    /**
     * @inheritDoc
     */
    HTTPTransport.prototype.sendPayload = function (payload, limitInMs) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var timeoutMS, call;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        timeoutMS = (_a = limitInMs !== null && limitInMs !== void 0 ? limitInMs : this.options.requestTimeoutMillis) !== null && _a !== void 0 ? _a : REQUEST_TIMEOUT_MILLIS_DEFAULT;
                        call = function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this._sendWithModule(payload, timeoutMS)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); };
                        return [4 /*yield*/, this._requestQueue.addToQueue(call)];
                    case 1: 
                    // Queue up the call to send the payload.
                    // Wait 10 seconds for each request in queue before removing it
                    return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    /** Returns a build request option object used by request */
    HTTPTransport.prototype._getRequestOptions = function () {
        var headers = __assign({}, this.options.headers);
        var url = new URL(this.options.serverUrl);
        var options = {
            headers: headers,
            method: 'POST',
            hostname: url.hostname,
            port: url.port,
            path: url.pathname,
        };
        return options;
    };
    /** JSDoc */
    HTTPTransport.prototype._sendWithModule = function (payload, limitInMs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            var timeoutId;
                            var req = _this.module.request(_this._getRequestOptions(), function (res) {
                                res.setEncoding('utf8');
                                var rawData = '';
                                // Collect the body data from the response
                                res.on('data', function (chunk) {
                                    rawData += chunk;
                                });
                                // On completion, parse the data and resolve.
                                res.on('end', function () {
                                    if (timeoutId !== undefined) {
                                        clearTimeout(timeoutId);
                                    }
                                    if (res.complete && rawData.length > 0) {
                                        try {
                                            var responseWithBody = mapJSONToResponse(JSON.parse(rawData));
                                            if (responseWithBody !== null) {
                                                return resolve(responseWithBody);
                                            }
                                        }
                                        catch (_a) {
                                            // pass
                                        }
                                    }
                                    // Fallback: get the response object directly from the incoming message
                                    resolve(mapHttpMessageToResponse(res));
                                });
                            });
                            // set timeout within promise so that it can resolve itself if time is exceeded
                            if (limitInMs > 0) {
                                timeoutId = setTimeout(function () {
                                    req.destroy();
                                    resolve({ status: Status.Timeout, statusCode: 0 });
                                }, limitInMs);
                            }
                            req.on('error', reject);
                            req.end(JSON.stringify(payload));
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return HTTPTransport;
}());
export { HTTPTransport };
export var setupDefaultTransport = function (options) {
    var transportOptions = {
        serverUrl: options.serverUrl,
        headers: {
            'Content-Type': 'application/json',
        },
        requestTimeoutMillis: options.requestTimeoutMillis,
    };
    return new HTTPTransport(transportOptions);
};
//# sourceMappingURL=http.js.map