{"version":3,"file":"offlineRetry.js","sourceRoot":"","sources":["../../../src/retry/offlineRetry.ts"],"names":[],"mappings":";AAAA,OAAO,EAA2B,MAAM,EAAY,MAAM,kBAAkB,CAAC;AAC7E,OAAO,EAAE,UAAU,EAAE,0BAA0B,EAAE,MAAM,kBAAkB,CAAC;AAC1E,OAAO,EAAE,gBAAgB,EAAE,MAAM,aAAa,CAAC;AAE/C;;;;GAIG;AACH;IAAyC,uCAAgB;IAIvD,6BAAmB,MAAc,EAAE,OAA8B;QAA9B,wBAAA,EAAA,YAA8B;QAAjE,YACE,kBAAM,MAAM,EAAE,OAAO,CAAC,SACvB;QALO,oBAAc,GAAY,EAAE,CAAC;QACpB,mBAAa,GAAe,IAAI,UAAU,EAAE,CAAC;;IAI9D,CAAC;IAED;;OAEG;IACU,iDAAmB,GAAhC,UAAiC,MAAwB;;;;;4BAChD,qBAAM,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC;;;;;wCACrC,QAAQ,GAAa,EAAE,MAAM,EAAE,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC;wCAC7D,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;;;;wCAG5B,qBAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC,EAAA;;wCAArD,QAAQ,GAAG,SAA0C,CAAC;wCACtD,IAAI,QAAQ,CAAC,MAAM,KAAK,MAAM,CAAC,OAAO,EAAE;4CACtC,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;yCAClC;6CAAM;4CACL,IAAI,CAAC,cAAc,EAAE,CAAC;yCACvB;;;;wCAED,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;;4CAG9C,sBAAO,QAAQ,EAAC;;;6BACjB,CAAC,EAAA;4BAhBF,sBAAO,SAgBL,EAAC;;;;KACJ;IAES,yCAAW,GAArB,UAAsB,MAAwB;QAC5C,kBACE,OAAO,EAAE,IAAI,CAAC,OAAO,EACrB,MAAM,EAAE,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,IACvC,IAAI,CAAC,kBAAkB,EAAE,EAC5B;IACJ,CAAC;IAEO,4CAAc,GAAtB;QACE,2DAA2D;QAC3D,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;IAC3B,CAAC;IAEO,0CAAY,GAApB,UAAqB,MAAwB,EAAE,QAAkB;;QAC/D,IAAI,gBAAgB,GAAY,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACnD,2DAA2D;QAC3D,IAAI,QAAQ,CAAC,MAAM,KAAK,MAAM,CAAC,OAAO,EAAE;YACtC,IAAI,cAAO,QAAQ,CAAC,IAAI,0CAAE,YAAY,CAAA,KAAK,QAAQ,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC1E,mEAAmE;gBACnE,+CAA+C;gBAC/C,gBAAgB,GAAG,EAAE,CAAC;aACvB;iBAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE;gBACtC,IAAM,qBAAmB,GAAG,IAAI,GAAG,CAAS,0BAA0B,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAClF,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,KAAK,IAAK,OAAA,CAAC,qBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,EAA/B,CAA+B,CAAC,CAAC;aACjF;SACF;aAAM,IAAI,QAAQ,CAAC,MAAM,KAAK,MAAM,CAAC,OAAO,EAAE;YAC7C,qEAAqE;YACrE,iDAAiD;YACjD,gBAAgB,GAAG,EAAE,CAAC;SACvB;QAED,IAAI,CAAC,cAAc,GAAG,gBAAgB,CAAC;QACvC,wDAAwD;QACxD,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE;YAC9D,IAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC;YACrF,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,EAAE,iBAAiB,CAAC,CAAC;SAClD;IACH,CAAC;IACH,0BAAC;AAAD,CAAC,AArED,CAAyC,gBAAgB,GAqExD","sourcesContent":["import { Event, Options, Payload, Status, Response } from '@amplitude/types';\nimport { AsyncQueue, collectInvalidEventIndices } from '@amplitude/utils';\nimport { BaseRetryHandler } from './baseRetry';\n\n/**\n * A retry handler made specifically to handle a strategy where\n * the server network connection is not always available. (e.g. executing node code on a client device).\n * Instead of retrying events on a loop, this will save untried events\n */\nexport class OfflineRetryHandler extends BaseRetryHandler {\n  private _eventsToRetry: Event[] = [];\n  private readonly _requestQueue: AsyncQueue = new AsyncQueue();\n\n  public constructor(apiKey: string, options: Partial<Options> = {}) {\n    super(apiKey, options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async sendEventsWithRetry(events: readonly Event[]): Promise<Response> {\n    return await this._requestQueue.addToQueue(async () => {\n      let response: Response = { status: Status.Unknown, statusCode: 0 };\n      const payload = this._getPayload(events);\n\n      try {\n        response = await this._transport.sendPayload(payload);\n        if (response.status !== Status.Success) {\n          throw new Error(response.status);\n        } else {\n          this._onSendSuccess();\n        }\n      } catch {\n        this._onSendError(payload.events, response);\n      }\n\n      return response;\n    });\n  }\n\n  protected _getPayload(events: readonly Event[]): Payload {\n    return {\n      api_key: this._apiKey,\n      events: this._eventsToRetry.concat(events),\n      ...this._getPayloadOptions(),\n    };\n  }\n\n  private _onSendSuccess(): void {\n    // If we successfully sent all the events, reset the queue!\n    this._eventsToRetry = [];\n  }\n\n  private _onSendError(events: readonly Event[], response: Response): void {\n    let newEventsToRetry: Event[] = Array.from(events);\n    // See if there are any events we can immediately throw out\n    if (response.status === Status.Invalid) {\n      if (typeof response.body?.missingField === 'string' || events.length === 1) {\n        // Don't retry anything if there's an issue with the entire payload\n        // or if there's only one event and its invalid\n        newEventsToRetry = [];\n      } else if (response.body !== undefined) {\n        const invalidEventIndices = new Set<number>(collectInvalidEventIndices(response));\n        newEventsToRetry = events.filter((_, index) => !invalidEventIndices.has(index));\n      }\n    } else if (response.status === Status.Success) {\n      // In case _onEventsError was called when we were actually successful\n      // In which case, why even start retrying events?\n      newEventsToRetry = [];\n    }\n\n    this._eventsToRetry = newEventsToRetry;\n    // If we have too many events, delete the OLDEST events.\n    if (this._eventsToRetry.length > this._options.maxCachedEvents) {\n      const numExceededEvents = this._eventsToRetry.length - this._options.maxCachedEvents;\n      this._eventsToRetry.splice(0, numExceededEvents);\n    }\n  }\n}\n"]}