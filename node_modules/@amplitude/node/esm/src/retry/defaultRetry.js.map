{"version":3,"file":"defaultRetry.js","sourceRoot":"","sources":["../../../src/retry/defaultRetry.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, Options, Status, Response } from '@amplitude/types';\nimport { BASE_RETRY_TIMEOUT_DEPRECATED, BASE_RETRY_TIMEOUT_DEPRECATED_WARNING } from '../constants';\nimport { asyncSleep, collectInvalidEventIndices, logger } from '@amplitude/utils';\n\nimport { BaseRetryHandler } from './baseRetry';\n\ninterface RetryMetadata {\n  shouldRetry: boolean;\n  shouldReduceEventCount: boolean;\n  eventIndicesToRemove: number[];\n  response: Response;\n}\n\n/**\n * Converts deprecated maxRetries option to retryTimeouts\n */\nfunction convertMaxRetries(maxRetries: number): number[] {\n  const retryTimeouts = [];\n  let currentTimeout = BASE_RETRY_TIMEOUT_DEPRECATED;\n  for (let i = 0; i < maxRetries; i++) {\n    retryTimeouts.push(currentTimeout);\n    currentTimeout *= 2;\n  }\n  return retryTimeouts;\n}\n\nfunction isNodeError(err: Error & NodeJS.ErrnoException): boolean {\n  return err.code !== undefined && err.errno !== undefined && err.syscall !== undefined;\n}\n\nexport class RetryHandler extends BaseRetryHandler {\n  // A map of maps to event buffers for failed events\n  // The first key is userId (or ''), and second is deviceId (or '')\n  private readonly _idToBuffer: Map<string, Map<string, Event[]>> = new Map<string, Map<string, Event[]>>();\n  private _eventsInRetry = 0;\n\n  public constructor(apiKey: string, options: Partial<Options> = {}) {\n    super(apiKey, options);\n    if (this._options.maxRetries !== undefined) {\n      logger.warn(BASE_RETRY_TIMEOUT_DEPRECATED_WARNING);\n      this._options.retryTimeouts = convertMaxRetries(this._options.maxRetries);\n      delete this._options.maxRetries;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async sendEventsWithRetry(events: readonly Event[]): Promise<Response> {\n    let response: Response = { status: Status.Unknown, statusCode: 0 };\n    let eventsToSend: Event[] = [];\n    try {\n      eventsToSend = this._pruneEvents(events);\n      response = await this._transport.sendPayload(this._getPayload(eventsToSend));\n      if (response.status !== Status.Success) {\n        throw new Error(response.status);\n      }\n    } catch (err) {\n      if (isNodeError(err)) {\n        response = {\n          status: Status.SystemError,\n          statusCode: 0,\n          error: err,\n        };\n      } else {\n        logger.warn('Unknown error caught when sending events');\n        logger.warn(err);\n      }\n      if (this._shouldRetryEvents()) {\n        this._onEventsError(eventsToSend, response);\n      }\n    }\n\n    return response;\n  }\n\n  private _shouldRetryEvents(): boolean {\n    if (this._options.retryTimeouts.length === 0) {\n      return false;\n    }\n\n    // TODO: Refine logic of what happens when we reach the queue limit.\n    return this._eventsInRetry < this._options.maxCachedEvents;\n  }\n\n  // Sends events with ids currently in active retry buffers straight\n  // to the retry buffer they should be in\n  private _pruneEvents(events: readonly Event[]): Event[] {\n    const prunedEvents: Event[] = [];\n    if (Array.isArray(events)) {\n      for (const event of events) {\n        const { user_id: userId = '', device_id: deviceId = '' } = event;\n        // We can ignore events with neither. They would fail anyways when sent as event.\n        if (userId.length > 0 || deviceId.length > 0) {\n          const retryBuffer = this._getRetryBuffer(userId, deviceId);\n          if (retryBuffer !== null) {\n            retryBuffer.push(event);\n            this._eventsInRetry++;\n          } else {\n            prunedEvents.push(event);\n          }\n        }\n      }\n    }\n\n    return prunedEvents;\n  }\n\n  private _getRetryBuffer(userId: string, deviceId: string): Event[] | null {\n    const deviceToBufferMap = this._idToBuffer.get(userId);\n    if (deviceToBufferMap === undefined) {\n      return null;\n    }\n\n    return deviceToBufferMap.get(deviceId) ?? null;\n  }\n\n  // cleans up the id to buffer map if the job is done\n  private _cleanUpBuffer(userId: string, deviceId: string): void {\n    const deviceToBufferMap = this._idToBuffer.get(userId);\n    if (deviceToBufferMap === undefined) {\n      return;\n    }\n\n    const eventsToRetry = deviceToBufferMap.get(deviceId);\n    if (eventsToRetry !== undefined && eventsToRetry.length === 0) {\n      deviceToBufferMap.delete(deviceId);\n    }\n\n    if (deviceToBufferMap.size === 0) {\n      this._idToBuffer.delete(userId);\n    }\n  }\n\n  private _onEventsError(events: readonly Event[], response: Response): void {\n    let eventsToRetry: readonly Event[] = events;\n    // See if there are any events we can immediately throw out\n    if (response.status === Status.RateLimit && response.body !== undefined) {\n      const { exceededDailyQuotaUsers, exceededDailyQuotaDevices } = response.body;\n      eventsToRetry = events.filter(({ user_id: userId, device_id: deviceId }) => {\n        return (\n          !(userId !== undefined && userId in exceededDailyQuotaUsers) &&\n          !(deviceId !== undefined && deviceId in exceededDailyQuotaDevices)\n        );\n      });\n    } else if (response.status === Status.Invalid) {\n      if (typeof response.body?.missingField === 'string' || events.length === 1) {\n        // Return early if there's an issue with the entire payload\n        // or if there's only one event and its invalid\n        return;\n      } else if (response.body !== undefined) {\n        const invalidEventIndices = new Set<number>(collectInvalidEventIndices(response));\n        eventsToRetry = events.filter((_, index) => !invalidEventIndices.has(index));\n      }\n    } else if (response.status === Status.Success) {\n      // In case _onEventsError was called when we were actually successful\n      // In which case, why even start retrying events?\n      return;\n    }\n\n    eventsToRetry.forEach((event: Event) => {\n      const { user_id: userId = '', device_id: deviceId = '' } = event;\n      if (userId.length > 0 || deviceId.length > 0) {\n        let deviceToBufferMap = this._idToBuffer.get(userId);\n        if (deviceToBufferMap === undefined) {\n          deviceToBufferMap = new Map<string, Event[]>();\n          this._idToBuffer.set(userId, deviceToBufferMap);\n        }\n\n        let retryBuffer = deviceToBufferMap.get(deviceId);\n        if (retryBuffer === undefined) {\n          retryBuffer = [];\n          deviceToBufferMap.set(deviceId, retryBuffer);\n          // In the next event loop, start retrying these events\n          setTimeout(() => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._retryEventsOnLoop(userId, deviceId);\n          }, 0);\n        }\n\n        this._eventsInRetry++;\n        retryBuffer.push(event);\n      }\n    });\n  }\n\n  private async _retryEventsOnce(\n    userId: string,\n    deviceId: string,\n    eventsToRetry: readonly Event[],\n  ): Promise<RetryMetadata> {\n    try {\n      const response = await this._transport.sendPayload(this._getPayload(eventsToRetry));\n\n      let shouldRetry = true;\n      let shouldReduceEventCount = false;\n      let eventIndicesToRemove: number[] = [];\n\n      if (response.status === Status.RateLimit) {\n        // RateLimit: See if we hit the daily quota\n        if (response.body !== undefined) {\n          const { exceededDailyQuotaUsers, exceededDailyQuotaDevices } = response.body;\n          if (deviceId in exceededDailyQuotaDevices || userId in exceededDailyQuotaUsers) {\n            shouldRetry = false; // This device/user may not be retried for a while. Just give up.\n          }\n        }\n\n        shouldReduceEventCount = true; // Reduce the payload to reduce risk of throttling\n      } else if (response.status === Status.PayloadTooLarge) {\n        shouldReduceEventCount = true;\n      } else if (response.status === Status.Invalid) {\n        if (eventsToRetry.length === 1) {\n          shouldRetry = false; // If there's only one event, just toss it.\n        } else {\n          eventIndicesToRemove = collectInvalidEventIndices(response); // Figure out which events need to go.\n        }\n      } else if (response.status === Status.Success) {\n        // Success! We sent the events\n        shouldRetry = false; // End the retry loop\n      }\n\n      return { shouldRetry, shouldReduceEventCount, eventIndicesToRemove, response };\n    } catch (err) {\n      return {\n        shouldRetry: false,\n        shouldReduceEventCount: false,\n        eventIndicesToRemove: [],\n        response: {\n          status: Status.SystemError,\n          statusCode: 0,\n          error: err instanceof Error ? err : new Error(String(err)),\n        },\n      };\n    }\n  }\n\n  private async _retryEventsOnLoop(userId: string, deviceId: string): Promise<void> {\n    const eventsBuffer = this._getRetryBuffer(userId, deviceId);\n    if (eventsBuffer === null || eventsBuffer.length === 0) {\n      this._cleanUpBuffer(userId, deviceId);\n      return;\n    }\n\n    let eventCount = eventsBuffer.length;\n\n    for (let numRetries = 0; numRetries < this._options.retryTimeouts.length; numRetries++) {\n      const sleepDuration = this._options.retryTimeouts[numRetries];\n      await asyncSleep(sleepDuration);\n      const isLastTry = numRetries === this._options.retryTimeouts.length;\n      const eventsToRetry = eventsBuffer.slice(0, eventCount);\n      const { shouldRetry, shouldReduceEventCount, eventIndicesToRemove, response } = await this._retryEventsOnce(\n        userId,\n        deviceId,\n        eventsToRetry,\n      );\n      if (this._options.onRetry !== null)\n        this._options.onRetry(response, numRetries, numRetries === this._options.retryTimeouts.length - 1);\n\n      if (eventIndicesToRemove.length > 0) {\n        let numEventsRemoved = 0;\n        // Reverse the indices so that splicing doesn't cause any indexing issues.\n        Array.from(eventIndicesToRemove)\n          .reverse()\n          .forEach(index => {\n            if (index < eventCount) {\n              eventsBuffer.splice(index, 1);\n              numEventsRemoved += 1;\n            }\n          });\n\n        eventCount -= numEventsRemoved;\n        this._eventsInRetry -= eventCount;\n        if (eventCount < 1) {\n          break; // If we managed to remove all the events, break off early.\n        }\n      }\n      if (!shouldRetry) {\n        break; // We ended!\n      }\n\n      if (shouldReduceEventCount && !isLastTry) {\n        eventCount = Math.max(eventCount >> 1, 1);\n      }\n    }\n\n    // Clean up the events\n    // Either because they were sent, or because we decided to no longer try them\n    eventsBuffer.splice(0, eventCount);\n    this._eventsInRetry -= eventCount;\n\n    // if more events came in during this time,\n    // retry them on a new loop\n    // otherwise, this call will immediately return on the next event loop.\n    setTimeout(() => {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._retryEventsOnLoop(userId, deviceId);\n    }, 0);\n  }\n}\n"]}