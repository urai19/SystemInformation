import { __assign, __awaiter, __generator } from "tslib";
import { Identify } from '@amplitude/identify';
import { SKIPPED_RESPONSE, } from '@amplitude/types';
import { logger, isNodeEnv, isValidEvent } from '@amplitude/utils';
import { RetryHandler } from './retry/defaultRetry';
import { SDK_NAME, SDK_VERSION, DEFAULT_OPTIONS } from './constants';
import { MiddlewareRunner } from './middleware/middlewareRunner';
var NodeClient = /** @class */ (function () {
    /**
     * Initializes this client instance.
     *
     * @param apiKey API key for your project
     * @param options options for the client
     */
    function NodeClient(apiKey, options) {
        if (options === void 0) { options = {}; }
        var _a;
        this._events = [];
        this._responseListeners = [];
        this._flushTimer = null;
        this._apiKey = apiKey;
        this._options = Object.assign({}, DEFAULT_OPTIONS, options);
        this._setUpLogging();
        this._transportWithRetry = (_a = this._options.retryClass) !== null && _a !== void 0 ? _a : this._setupDefaultTransport();
        this._middlewareRunner = new MiddlewareRunner();
        if (!isNodeEnv()) {
            logger.warn('@amplitude/node initialized in a non-node environment and will not work. If you are planning to add Amplitude to a browser environment, please use amplitude-js');
        }
    }
    /**
     * @inheritDoc
     */
    NodeClient.prototype.getOptions = function () {
        return this._options;
    };
    /**
     * @inheritDoc
     */
    NodeClient.prototype.flush = function () {
        return __awaiter(this, void 0, void 0, function () {
            var responseListeners, eventsToSend, response_1, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Clear the timeout
                        if (this._flushTimer !== null) {
                            clearTimeout(this._flushTimer);
                            this._flushTimer = null;
                        }
                        // Check if there's 0 events, flush is not needed.
                        if (this._events.length === 0) {
                            return [2 /*return*/, SKIPPED_RESPONSE];
                        }
                        responseListeners = this._responseListeners;
                        this._responseListeners = [];
                        eventsToSend = this._events;
                        this._events = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._transportWithRetry.sendEventsWithRetry(eventsToSend)];
                    case 2:
                        response_1 = _a.sent();
                        responseListeners.forEach(function (_a) {
                            var resolve = _a.resolve;
                            return resolve(response_1);
                        });
                        return [2 /*return*/, response_1];
                    case 3:
                        err_1 = _a.sent();
                        responseListeners.forEach(function (_a) {
                            var reject = _a.reject;
                            return reject(err_1);
                        });
                        throw err_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @inheritDoc
     */
    NodeClient.prototype.logEvent = function (event, extra) {
        return __awaiter(this, void 0, void 0, function () {
            var middlewareCompleted;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._options.optOut) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.resolve(SKIPPED_RESPONSE)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        this._annotateEvent(event);
                        this._observeEvent(event);
                        middlewareCompleted = false;
                        this._middlewareRunner.run({ event: event, extra: extra }, function () {
                            middlewareCompleted = true;
                        });
                        if (!!middlewareCompleted) return [3 /*break*/, 4];
                        logger.warn('Middleware chain skipped logEvent action.');
                        return [4 /*yield*/, Promise.resolve(SKIPPED_RESPONSE)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        if (!!isValidEvent(event)) return [3 /*break*/, 6];
                        logger.warn('Found invalid event - skipping logEvent action.');
                        return [4 /*yield*/, Promise.resolve(SKIPPED_RESPONSE)];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            // Add event to unsent events queue.
                            _this._events.push(event);
                            _this._responseListeners.push({ resolve: resolve, reject: reject });
                            if (_this._events.length >= _this._options.maxCachedEvents) {
                                // # of events exceeds the limit, flush them.
                                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                                _this.flush();
                            }
                            else {
                                // Not ready to flush them and not timing yet, then set the timeout
                                if (_this._flushTimer === null) {
                                    _this._flushTimer = setTimeout(function () {
                                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                                        _this.flush();
                                    }, _this._options.uploadIntervalInSec * 1000);
                                }
                            }
                        })];
                    case 7: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Sends an identify request for a specific user and device ID, given an identify event.
     * Functionally similar to calling logEvent on an event created by the identify object
     *
     * @param userId the user ID that user properties are being attached to
     * @param deviceId the device ID that user properties are being attached to.
     * @param identify the Identify instance containing user property information
     * @returns a Promise containing metadata about the success of sending this identify to the Amplitude API
     */
    NodeClient.prototype.identify = function (userId, deviceId, identify) {
        return __awaiter(this, void 0, void 0, function () {
            var identifyEvent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!(identify instanceof Identify)) return [3 /*break*/, 2];
                        logger.warn('Invalid Identify object. Skipping operation.');
                        return [4 /*yield*/, Promise.resolve(SKIPPED_RESPONSE)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        identifyEvent = identify.identifyUser(userId, deviceId);
                        return [4 /*yield*/, this.logEvent(identifyEvent)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    NodeClient.prototype.addEventMiddleware = function (middleware) {
        this._middlewareRunner.add(middleware);
        return this;
    };
    /** Add platform dependent field onto event. */
    NodeClient.prototype._annotateEvent = function (event) {
        event.library = SDK_NAME + "/" + SDK_VERSION;
    };
    /** Merge plan field into event */
    NodeClient.prototype._observeEvent = function (event) {
        if (typeof this._options.plan !== 'undefined') {
            event.plan = __assign(__assign({}, this._options.plan), event.plan);
        }
    };
    NodeClient.prototype._setupDefaultTransport = function () {
        return new RetryHandler(this._apiKey, this._options);
    };
    NodeClient.prototype._setUpLogging = function () {
        if (this._options.debug || this._options.logLevel > 0) {
            if (this._options.logLevel > 0) {
                logger.enable(this._options.logLevel);
            }
            else {
                logger.enable();
            }
        }
    };
    return NodeClient;
}());
export { NodeClient };
//# sourceMappingURL=nodeClient.js.map