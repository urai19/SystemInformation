Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryHandler = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@amplitude/types");
var constants_1 = require("../constants");
var utils_1 = require("@amplitude/utils");
var baseRetry_1 = require("./baseRetry");
/**
 * Converts deprecated maxRetries option to retryTimeouts
 */
function convertMaxRetries(maxRetries) {
    var retryTimeouts = [];
    var currentTimeout = constants_1.BASE_RETRY_TIMEOUT_DEPRECATED;
    for (var i = 0; i < maxRetries; i++) {
        retryTimeouts.push(currentTimeout);
        currentTimeout *= 2;
    }
    return retryTimeouts;
}
function isNodeError(err) {
    return err.code !== undefined && err.errno !== undefined && err.syscall !== undefined;
}
var RetryHandler = /** @class */ (function (_super) {
    tslib_1.__extends(RetryHandler, _super);
    function RetryHandler(apiKey, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, apiKey, options) || this;
        // A map of maps to event buffers for failed events
        // The first key is userId (or ''), and second is deviceId (or '')
        _this._idToBuffer = new Map();
        _this._eventsInRetry = 0;
        if (_this._options.maxRetries !== undefined) {
            utils_1.logger.warn(constants_1.BASE_RETRY_TIMEOUT_DEPRECATED_WARNING);
            _this._options.retryTimeouts = convertMaxRetries(_this._options.maxRetries);
            delete _this._options.maxRetries;
        }
        return _this;
    }
    /**
     * @inheritDoc
     */
    RetryHandler.prototype.sendEventsWithRetry = function (events) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, eventsToSend, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        response = { status: types_1.Status.Unknown, statusCode: 0 };
                        eventsToSend = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        eventsToSend = this._pruneEvents(events);
                        return [4 /*yield*/, this._transport.sendPayload(this._getPayload(eventsToSend))];
                    case 2:
                        response = _a.sent();
                        if (response.status !== types_1.Status.Success) {
                            throw new Error(response.status);
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        if (isNodeError(err_1)) {
                            response = {
                                status: types_1.Status.SystemError,
                                statusCode: 0,
                                error: err_1,
                            };
                        }
                        else {
                            utils_1.logger.warn('Unknown error caught when sending events');
                            utils_1.logger.warn(err_1);
                        }
                        if (this._shouldRetryEvents()) {
                            this._onEventsError(eventsToSend, response);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, response];
                }
            });
        });
    };
    RetryHandler.prototype._shouldRetryEvents = function () {
        if (this._options.retryTimeouts.length === 0) {
            return false;
        }
        // TODO: Refine logic of what happens when we reach the queue limit.
        return this._eventsInRetry < this._options.maxCachedEvents;
    };
    // Sends events with ids currently in active retry buffers straight
    // to the retry buffer they should be in
    RetryHandler.prototype._pruneEvents = function (events) {
        var e_1, _a;
        var prunedEvents = [];
        if (Array.isArray(events)) {
            try {
                for (var events_1 = tslib_1.__values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
                    var event_1 = events_1_1.value;
                    var _b = event_1.user_id, userId = _b === void 0 ? '' : _b, _c = event_1.device_id, deviceId = _c === void 0 ? '' : _c;
                    // We can ignore events with neither. They would fail anyways when sent as event.
                    if (userId.length > 0 || deviceId.length > 0) {
                        var retryBuffer = this._getRetryBuffer(userId, deviceId);
                        if (retryBuffer !== null) {
                            retryBuffer.push(event_1);
                            this._eventsInRetry++;
                        }
                        else {
                            prunedEvents.push(event_1);
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return prunedEvents;
    };
    RetryHandler.prototype._getRetryBuffer = function (userId, deviceId) {
        var _a;
        var deviceToBufferMap = this._idToBuffer.get(userId);
        if (deviceToBufferMap === undefined) {
            return null;
        }
        return (_a = deviceToBufferMap.get(deviceId)) !== null && _a !== void 0 ? _a : null;
    };
    // cleans up the id to buffer map if the job is done
    RetryHandler.prototype._cleanUpBuffer = function (userId, deviceId) {
        var deviceToBufferMap = this._idToBuffer.get(userId);
        if (deviceToBufferMap === undefined) {
            return;
        }
        var eventsToRetry = deviceToBufferMap.get(deviceId);
        if (eventsToRetry !== undefined && eventsToRetry.length === 0) {
            deviceToBufferMap.delete(deviceId);
        }
        if (deviceToBufferMap.size === 0) {
            this._idToBuffer.delete(userId);
        }
    };
    RetryHandler.prototype._onEventsError = function (events, response) {
        var _this = this;
        var _a;
        var eventsToRetry = events;
        // See if there are any events we can immediately throw out
        if (response.status === types_1.Status.RateLimit && response.body !== undefined) {
            var _b = response.body, exceededDailyQuotaUsers_1 = _b.exceededDailyQuotaUsers, exceededDailyQuotaDevices_1 = _b.exceededDailyQuotaDevices;
            eventsToRetry = events.filter(function (_a) {
                var userId = _a.user_id, deviceId = _a.device_id;
                return (!(userId !== undefined && userId in exceededDailyQuotaUsers_1) &&
                    !(deviceId !== undefined && deviceId in exceededDailyQuotaDevices_1));
            });
        }
        else if (response.status === types_1.Status.Invalid) {
            if (typeof ((_a = response.body) === null || _a === void 0 ? void 0 : _a.missingField) === 'string' || events.length === 1) {
                // Return early if there's an issue with the entire payload
                // or if there's only one event and its invalid
                return;
            }
            else if (response.body !== undefined) {
                var invalidEventIndices_1 = new Set(utils_1.collectInvalidEventIndices(response));
                eventsToRetry = events.filter(function (_, index) { return !invalidEventIndices_1.has(index); });
            }
        }
        else if (response.status === types_1.Status.Success) {
            // In case _onEventsError was called when we were actually successful
            // In which case, why even start retrying events?
            return;
        }
        eventsToRetry.forEach(function (event) {
            var _a = event.user_id, userId = _a === void 0 ? '' : _a, _b = event.device_id, deviceId = _b === void 0 ? '' : _b;
            if (userId.length > 0 || deviceId.length > 0) {
                var deviceToBufferMap = _this._idToBuffer.get(userId);
                if (deviceToBufferMap === undefined) {
                    deviceToBufferMap = new Map();
                    _this._idToBuffer.set(userId, deviceToBufferMap);
                }
                var retryBuffer = deviceToBufferMap.get(deviceId);
                if (retryBuffer === undefined) {
                    retryBuffer = [];
                    deviceToBufferMap.set(deviceId, retryBuffer);
                    // In the next event loop, start retrying these events
                    setTimeout(function () {
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        _this._retryEventsOnLoop(userId, deviceId);
                    }, 0);
                }
                _this._eventsInRetry++;
                retryBuffer.push(event);
            }
        });
    };
    RetryHandler.prototype._retryEventsOnce = function (userId, deviceId, eventsToRetry) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, shouldRetry, shouldReduceEventCount, eventIndicesToRemove, _a, exceededDailyQuotaUsers, exceededDailyQuotaDevices, err_2;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this._transport.sendPayload(this._getPayload(eventsToRetry))];
                    case 1:
                        response = _b.sent();
                        shouldRetry = true;
                        shouldReduceEventCount = false;
                        eventIndicesToRemove = [];
                        if (response.status === types_1.Status.RateLimit) {
                            // RateLimit: See if we hit the daily quota
                            if (response.body !== undefined) {
                                _a = response.body, exceededDailyQuotaUsers = _a.exceededDailyQuotaUsers, exceededDailyQuotaDevices = _a.exceededDailyQuotaDevices;
                                if (deviceId in exceededDailyQuotaDevices || userId in exceededDailyQuotaUsers) {
                                    shouldRetry = false; // This device/user may not be retried for a while. Just give up.
                                }
                            }
                            shouldReduceEventCount = true; // Reduce the payload to reduce risk of throttling
                        }
                        else if (response.status === types_1.Status.PayloadTooLarge) {
                            shouldReduceEventCount = true;
                        }
                        else if (response.status === types_1.Status.Invalid) {
                            if (eventsToRetry.length === 1) {
                                shouldRetry = false; // If there's only one event, just toss it.
                            }
                            else {
                                eventIndicesToRemove = utils_1.collectInvalidEventIndices(response); // Figure out which events need to go.
                            }
                        }
                        else if (response.status === types_1.Status.Success) {
                            // Success! We sent the events
                            shouldRetry = false; // End the retry loop
                        }
                        return [2 /*return*/, { shouldRetry: shouldRetry, shouldReduceEventCount: shouldReduceEventCount, eventIndicesToRemove: eventIndicesToRemove, response: response }];
                    case 2:
                        err_2 = _b.sent();
                        return [2 /*return*/, {
                                shouldRetry: false,
                                shouldReduceEventCount: false,
                                eventIndicesToRemove: [],
                                response: {
                                    status: types_1.Status.SystemError,
                                    statusCode: 0,
                                    error: err_2 instanceof Error ? err_2 : new Error(String(err_2)),
                                },
                            }];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    RetryHandler.prototype._retryEventsOnLoop = function (userId, deviceId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var eventsBuffer, eventCount, _loop_1, this_1, numRetries, state_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        eventsBuffer = this._getRetryBuffer(userId, deviceId);
                        if (eventsBuffer === null || eventsBuffer.length === 0) {
                            this._cleanUpBuffer(userId, deviceId);
                            return [2 /*return*/];
                        }
                        eventCount = eventsBuffer.length;
                        _loop_1 = function (numRetries) {
                            var sleepDuration, isLastTry, eventsToRetry, _a, shouldRetry, shouldReduceEventCount, eventIndicesToRemove, response, numEventsRemoved_1;
                            return tslib_1.__generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        sleepDuration = this_1._options.retryTimeouts[numRetries];
                                        return [4 /*yield*/, utils_1.asyncSleep(sleepDuration)];
                                    case 1:
                                        _b.sent();
                                        isLastTry = numRetries === this_1._options.retryTimeouts.length;
                                        eventsToRetry = eventsBuffer.slice(0, eventCount);
                                        return [4 /*yield*/, this_1._retryEventsOnce(userId, deviceId, eventsToRetry)];
                                    case 2:
                                        _a = _b.sent(), shouldRetry = _a.shouldRetry, shouldReduceEventCount = _a.shouldReduceEventCount, eventIndicesToRemove = _a.eventIndicesToRemove, response = _a.response;
                                        if (this_1._options.onRetry !== null)
                                            this_1._options.onRetry(response, numRetries, numRetries === this_1._options.retryTimeouts.length - 1);
                                        if (eventIndicesToRemove.length > 0) {
                                            numEventsRemoved_1 = 0;
                                            // Reverse the indices so that splicing doesn't cause any indexing issues.
                                            Array.from(eventIndicesToRemove)
                                                .reverse()
                                                .forEach(function (index) {
                                                if (index < eventCount) {
                                                    eventsBuffer.splice(index, 1);
                                                    numEventsRemoved_1 += 1;
                                                }
                                            });
                                            eventCount -= numEventsRemoved_1;
                                            this_1._eventsInRetry -= eventCount;
                                            if (eventCount < 1) {
                                                return [2 /*return*/, "break"];
                                            }
                                        }
                                        if (!shouldRetry) {
                                            return [2 /*return*/, "break"];
                                        }
                                        if (shouldReduceEventCount && !isLastTry) {
                                            eventCount = Math.max(eventCount >> 1, 1);
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        numRetries = 0;
                        _a.label = 1;
                    case 1:
                        if (!(numRetries < this._options.retryTimeouts.length)) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_1(numRetries)];
                    case 2:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3 /*break*/, 4];
                        _a.label = 3;
                    case 3:
                        numRetries++;
                        return [3 /*break*/, 1];
                    case 4:
                        // Clean up the events
                        // Either because they were sent, or because we decided to no longer try them
                        eventsBuffer.splice(0, eventCount);
                        this._eventsInRetry -= eventCount;
                        // if more events came in during this time,
                        // retry them on a new loop
                        // otherwise, this call will immediately return on the next event loop.
                        setTimeout(function () {
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            _this._retryEventsOnLoop(userId, deviceId);
                        }, 0);
                        return [2 /*return*/];
                }
            });
        });
    };
    return RetryHandler;
}(baseRetry_1.BaseRetryHandler));
exports.RetryHandler = RetryHandler;
//# sourceMappingURL=defaultRetry.js.map