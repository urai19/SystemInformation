Object.defineProperty(exports, "__esModule", { value: true });
exports.OfflineRetryHandler = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@amplitude/types");
var utils_1 = require("@amplitude/utils");
var baseRetry_1 = require("./baseRetry");
/**
 * A retry handler made specifically to handle a strategy where
 * the server network connection is not always available. (e.g. executing node code on a client device).
 * Instead of retrying events on a loop, this will save untried events
 */
var OfflineRetryHandler = /** @class */ (function (_super) {
    tslib_1.__extends(OfflineRetryHandler, _super);
    function OfflineRetryHandler(apiKey, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, apiKey, options) || this;
        _this._eventsToRetry = [];
        _this._requestQueue = new utils_1.AsyncQueue();
        return _this;
    }
    /**
     * @inheritDoc
     */
    OfflineRetryHandler.prototype.sendEventsWithRetry = function (events) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._requestQueue.addToQueue(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var response, payload, _a;
                            return tslib_1.__generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        response = { status: types_1.Status.Unknown, statusCode: 0 };
                                        payload = this._getPayload(events);
                                        _b.label = 1;
                                    case 1:
                                        _b.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, this._transport.sendPayload(payload)];
                                    case 2:
                                        response = _b.sent();
                                        if (response.status !== types_1.Status.Success) {
                                            throw new Error(response.status);
                                        }
                                        else {
                                            this._onSendSuccess();
                                        }
                                        return [3 /*break*/, 4];
                                    case 3:
                                        _a = _b.sent();
                                        this._onSendError(payload.events, response);
                                        return [3 /*break*/, 4];
                                    case 4: return [2 /*return*/, response];
                                }
                            });
                        }); })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    OfflineRetryHandler.prototype._getPayload = function (events) {
        return tslib_1.__assign({ api_key: this._apiKey, events: this._eventsToRetry.concat(events) }, this._getPayloadOptions());
    };
    OfflineRetryHandler.prototype._onSendSuccess = function () {
        // If we successfully sent all the events, reset the queue!
        this._eventsToRetry = [];
    };
    OfflineRetryHandler.prototype._onSendError = function (events, response) {
        var _a;
        var newEventsToRetry = Array.from(events);
        // See if there are any events we can immediately throw out
        if (response.status === types_1.Status.Invalid) {
            if (typeof ((_a = response.body) === null || _a === void 0 ? void 0 : _a.missingField) === 'string' || events.length === 1) {
                // Don't retry anything if there's an issue with the entire payload
                // or if there's only one event and its invalid
                newEventsToRetry = [];
            }
            else if (response.body !== undefined) {
                var invalidEventIndices_1 = new Set(utils_1.collectInvalidEventIndices(response));
                newEventsToRetry = events.filter(function (_, index) { return !invalidEventIndices_1.has(index); });
            }
        }
        else if (response.status === types_1.Status.Success) {
            // In case _onEventsError was called when we were actually successful
            // In which case, why even start retrying events?
            newEventsToRetry = [];
        }
        this._eventsToRetry = newEventsToRetry;
        // If we have too many events, delete the OLDEST events.
        if (this._eventsToRetry.length > this._options.maxCachedEvents) {
            var numExceededEvents = this._eventsToRetry.length - this._options.maxCachedEvents;
            this._eventsToRetry.splice(0, numExceededEvents);
        }
    };
    return OfflineRetryHandler;
}(baseRetry_1.BaseRetryHandler));
exports.OfflineRetryHandler = OfflineRetryHandler;
//# sourceMappingURL=offlineRetry.js.map