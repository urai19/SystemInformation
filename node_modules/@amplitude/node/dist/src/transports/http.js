Object.defineProperty(exports, "__esModule", { value: true });
exports.setupDefaultTransport = exports.HTTPTransport = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@amplitude/types");
var utils_1 = require("@amplitude/utils");
var http = require("http");
var https = require("https");
var constants_1 = require("../constants");
/** Base Transport class implementation */
var HTTPTransport = /** @class */ (function () {
    /** Create instance and set this.dsn */
    function HTTPTransport(options) {
        this.options = options;
        this._uploadInProgress = false;
        this._requestQueue = new utils_1.AsyncQueue();
        this.options = options;
        if (options.serverUrl.startsWith('http://')) {
            this.module = http;
        }
        else if (options.serverUrl.startsWith('https://')) {
            this.module = https;
        }
        else {
            throw new Error('Invalid server url');
        }
    }
    /**
     * @inheritDoc
     */
    HTTPTransport.prototype.sendPayload = function (payload, limitInMs) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var timeoutMS, call;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        timeoutMS = (_a = limitInMs !== null && limitInMs !== void 0 ? limitInMs : this.options.requestTimeoutMillis) !== null && _a !== void 0 ? _a : constants_1.REQUEST_TIMEOUT_MILLIS_DEFAULT;
                        call = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this._sendWithModule(payload, timeoutMS)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); };
                        return [4 /*yield*/, this._requestQueue.addToQueue(call)];
                    case 1: 
                    // Queue up the call to send the payload.
                    // Wait 10 seconds for each request in queue before removing it
                    return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    /** Returns a build request option object used by request */
    HTTPTransport.prototype._getRequestOptions = function () {
        var headers = tslib_1.__assign({}, this.options.headers);
        var url = new URL(this.options.serverUrl);
        var options = {
            headers: headers,
            method: 'POST',
            hostname: url.hostname,
            port: url.port,
            path: url.pathname,
        };
        return options;
    };
    /** JSDoc */
    HTTPTransport.prototype._sendWithModule = function (payload, limitInMs) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            var timeoutId;
                            var req = _this.module.request(_this._getRequestOptions(), function (res) {
                                res.setEncoding('utf8');
                                var rawData = '';
                                // Collect the body data from the response
                                res.on('data', function (chunk) {
                                    rawData += chunk;
                                });
                                // On completion, parse the data and resolve.
                                res.on('end', function () {
                                    if (timeoutId !== undefined) {
                                        clearTimeout(timeoutId);
                                    }
                                    if (res.complete && rawData.length > 0) {
                                        try {
                                            var responseWithBody = utils_1.mapJSONToResponse(JSON.parse(rawData));
                                            if (responseWithBody !== null) {
                                                return resolve(responseWithBody);
                                            }
                                        }
                                        catch (_a) {
                                            // pass
                                        }
                                    }
                                    // Fallback: get the response object directly from the incoming message
                                    resolve(utils_1.mapHttpMessageToResponse(res));
                                });
                            });
                            // set timeout within promise so that it can resolve itself if time is exceeded
                            if (limitInMs > 0) {
                                timeoutId = setTimeout(function () {
                                    req.destroy();
                                    resolve({ status: types_1.Status.Timeout, statusCode: 0 });
                                }, limitInMs);
                            }
                            req.on('error', reject);
                            req.end(JSON.stringify(payload));
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return HTTPTransport;
}());
exports.HTTPTransport = HTTPTransport;
exports.setupDefaultTransport = function (options) {
    var transportOptions = {
        serverUrl: options.serverUrl,
        headers: {
            'Content-Type': 'application/json',
        },
        requestTimeoutMillis: options.requestTimeoutMillis,
    };
    return new HTTPTransport(transportOptions);
};
//# sourceMappingURL=http.js.map